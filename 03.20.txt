PL/SQL 은 Oracle Database 와 함께 사용되는 데이터베이스 언어이다.
MYSQL은 SQL언어를 사용하는 데이터 베이스이다.
하지만 조금 다른 SQL언어를 사용한다. 차이점은 MYSQL은 데이터베이스이고 PL/SQL은 작업하는언어이다.
SQL은 SQLSERVER,ORACLE,MYSQL,PostgreSQL,DB2,infomix등 모든 관계형 데이터베이스 관리시스템이서 표준화 되어 사용된다. 
PL/SQL은 오라클에서 사용되는 독점적 절차 언어이다.
PL/pgSQL은 PostgreSQL에서 사용되는 절차 언어이다.
TSQL은 Microsoft에서 사용되는 독점적 절차 언어이다.
절차언어는 SQL과 잘 통합되는 동시에 SQL의 기능확장하도록 설계되어있다.
지역변수 및 문자열 데이터 처리와 같은 기능이 추가되어 있다. 지역변수,문자열 ,데이터처리와 같은 기능이 있다.
이러한 기능을 통해 Turing언어가 완성된다. 또한 프로시저를 작성하는데 사용되고 순수 세트 기반 조작으로 관리하기 어렵거나 불가능한 복잡한 비즈니스 규칙을 관리하기 위하여 사용된다.
PL/SQL은 SQL과 프로그래밍 언어의 기능을 결합한 것이다. 이것은 SQL기능을 향상시키기 위하여 ORACLE에서 개발 하였습니다. 

샘플스키마는 기본적으로 9가지가 있다. 
employees:사원테이블(사원번호,사원명,부서번호,등)
departments:부서테이블(부서번호,부서명 등)
jobs:job 테이블(job번호,명칭 등)
job_history:job_history테이블(job번호, 사원번호, 부서번호 등)
contries:국가 테이블(국가번호,국가코드,국가명 등)
customers:고객테이블(고객번호,고객명,국가번호 등)
channels:판매 채널테이블(채널번호,채널명 등)
products:제품 테이블(제품번호, 제품명 등)
sales:판매 테이블(제품번호, 고객번호, 채널번호, 사원번호 등)

RDBMS는 최소한의 데이터를 테이블에 담은후 연결고리를 이용해서 테이블을 연결하고 데이터를 추출한다
사원과 부서 테이블은 부서번호로 연결되어있고 해당사원이 무슨 부서에 소속되어있는지 알수 있고, 국가와 고객은 
국가번호로 연결되어 해당고객이 어느나라 소속인지 알 수 있다 이를 ERD: Entity Relationship Diagram이라고 한다.

LOB 데이터 타입 
Large Object라고 하며 대용량 데이터를 저장 할 수있는 데이터 타입이다.
제약조건은 컬럼에 대한 속성 형태로 정의 하지만 엄연히오라클 데이터베이스 겍체중 하니이고 데이터 무결성을 보장하기 위한 용도로 사용된다. 
UNIQUE는 유일한 데이터이고 중복을 허용하지 않겠다는 의미이다. CONSTRAINT는 강제라는 의미이고 UNIQUE를 사용할때 만든다. 
기본키는 Primary key라고하고 기본키를 의미한다. UNIQUE와 NOTNULL의 속성을 동시에 가진 제약조건이다.
외래키는 Foreign Key라고하고 테이블간의 참조 데이터 무결성을 위한 제약조건이다.
CONSTRAINT 외래키명 FORIGN KEY(칼럼명,...)
REFFERENCE 참조 테이블(참조 테이블 칼럼명,..)
부서테이블에 없는 부서번호를 입력한다면 참조 무결성이 깨지지만 외래키를 생성해놓으면 부서정보에 없는 부서번호를 입력할때 오류를 발생시켜 잘못된 데이터가 입력되는 것을 방지한다. 삭제도 마찬가지이다 사원테이블에서 사용되고 있는 부서정보를 부서 테이블에서 삭제하면 무결성이 깨지기 때문에 외래키를 생성해 놓으면 부서 테이블에서 부서번호를 삭제 할때 무결성이 보장된다. 변경하는 것도 해당이 된다. 외래키 생성의 제약조건은 참조하는 테이블이 먼저 생성되어야 하고 참조키가 테이블의 기본키로 만들어져 있어야하고 외래키에서 사용할 수있는 칼럼수는 32개이다 여러 칼럼을 외래키로 만들시 참조하는 칼럼의 순서와 갯수는 같아야한다.
CHECK제약조건 칼럼에 입력되는 데이터를 체크해 특정 조건이 맞는 데이터만 입력받고 그렇지 않으면 오류 발생한다.

테이블 삭제 DROP TABLE 스키마.테이블명 CASCADE CONSTRAINTS
칼럼명 변경 ALTER TABLE 스키마.테이블명 RENAME COLUM 변경전이름 TO 변경후이름;
칼럼타입 변경 ALTER TABLE 스키마.테이블명 MODIFY 칼럼명 데이터타입;
칼럼 추가 ALTER TABLE 스키마.테이블명 ADD 칼럼명 데이터타입;
칼럼 삭제 ALTER TABLE 스키마.테이블명 DROP COLUMN 칼럼명;
제약조건추가 ALTER TABLE 스키마.테이블명 ADD CONSTRAINTS 제약조건명 PRIMARY KEY(칼럼명,..);
제약조건삭제 ALTER TABLE 스키마.테이블명 DROP CONSTRAINTS 제약조건명;
테이블 복사 CREATE TABLE 스키마.테이블명 AS SELECT 칼럼1,칼럼2....FROM 복사할 테이블명;(CTAS라고 부름)



뷰는 하나 이상의 테이블이나 다른 뷰의 데이터를 볼 수있게하는 데이터 베이스 객체이다. 실제 데이터는 뷰를 구성하는 테이블에 담겨져 있지만 테이블처럼 사용이 가능하다. 또한 테이블 뿐만 아니라 다른 뷰를 참조해서 새로운 뷰를 만들어 사용할 수있다. 데이터를 본다의 의미 가있고 뷰는 테이블을 조회하는 SELECT문으로 구성된다.
--------------------------------------------------------------------------------------------------
1. 뷰는 사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된, 이름을 가지는 가상 테이블이다.

2. 뷰는 저장장치 내에 물리적으로 존재하지 않지만 사용자에게 있는 것처럼 간주된다.

3. 뷰는 데이터 보정작업, 처리과정 시험 등 임시적인 작업을 위한 용도로 활용된다.

4. 뷰는 조인문의 사용 최소화로 사용상의 편의성을 최대화 한다.
뷰(View)의 특징

1. 뷰는 기본테이블로부터 유도된 테이블이기 때문에 기본 테이블과 같은 형태의 구조를 사용하며, 조작도 기본 테이블과 거의 같다.

2. 뷰는 가상 테이블이기 때문에 물리적으로 구현되어 있지 않다.

3. 데이터의 논리적 독립성을 제공할 수 있다.

4. 필요한 데이터만 뷰로 정의해서 처리할 수 있기 때문에 관리가 용이하고 명령문이 간단해진다.

5. 뷰를 통해서만 데이터에 접근하게 하면 뷰에 나타나지 않는 데이터를 안전하게 보호하는 효율적인 기법으로 사용할 수 있다.

6. 기본 테이블의 기본키를 포함한 속성(열) 집합으로 뷰를 구성해야지만 삽입, 삭제, 갱신, 연산이 가능하다.

7. 일단 정의된 뷰는 다른 뷰의 정의에 기초가 될 수 있다.

8. 뷰가 정의된 기본 테이블이나 뷰를 삭제하면 그 테이블이나 뷰를 기초로 정의된 다른 뷰도 자동으로 삭제된다.



뷰(View)사용시 장 단점

장점

1. 논리적 데이터 독립성을 제공한다.

2. 동일 데이터에 대해 동시에 여러사용자의 상이한 응용이나 요구를 지원해 준다.

3. 사용자의 데이터관리를 간단하게 해준다.

4. 접근 제어를 통한 자동 보안이 제공된다.



단점

1. 독립적인 인덱스를 가질 수 없다.

2. ALTER VIEW문을 사용할 수 없다. 즉 뷰의 정의를 변경할 수 없다.

3. 뷰로 구성된 내용에 대한 삽입, 삭제, 갱신, 연산에 제약이 따른다.






-문법--
CREATE VIEW 뷰이름[(속성이름[,속성이름])]AS SELECT문;

--고객 테이블에서 주소가 서울시인 고객들의 성명과 전화번호를 서울고객이라는 뷰로 만들어라--
CREATE VIEW 서울고객(성명, 전화번호)
AS SELECT 성명 전화번호
FROM 고객
WHERE 주소 = '서울시';



뷰는 가상의 테이블을 제공하는 것이고 뷰는 논리적 데이터 독립성을 제공하고 데이터 조작연산을 간소화하며 접근제어를 통한 보안 기능을 제공한다.
--------------------------------------------------------------------------------------------------
뷰 생성 CREATE OR REPLACE 스키마.뷰명 AS SELECT 문장;
뷰 삭제 DROP VIEW 스키마.뷰명;


인덱스는 테이블에 있는 데이터를 빨리 찾기 위한 용도를 가진 데이터베이스 겍체이다.
인덱스 구성 칼럼개수에 따른 분류 :단일 인덱스, 결합인덱스(형태와 속성)
유일성 여부에 따른 분류 : UNIQUE 인덱스 , NON-UNIQUE인덱스(형태와 속성)
인덱스 내부구조에 따른 분류 : B-TREE 인덱스, 비트멥인덱스, 함수 기반 인덱스(내부 알고리즘)
------------------------------------------------------------------------------------------------------
B-tree index는 인덱스 키와 키에 해당하는 칼럼 값을 가진 테이블의 로우가 저장된 주소 값으로 구성된다.

B-Tree 알고리즘은 가장 일반적으로 사용되는 인덱스 알고리즘으로서, 상당히 오래전에 도입된 알고리즘이며 그만큼 성숙해진 상태입니다. B-Tree 인덱스는 칼럼의 값을 변형하지 않고, 원래의 값을 이용해 인덱싱하는 알고리즘 입니다.



Hash 인덱스 알고리즘은 컬럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘으로, 매우 빠른 검색을 지원합니다. 하지만 값을 변형해서 인덱싱하므로, 전방(Prefix) 일치와 같이 값의 일부만 검색하고자 할 때는 해시 인덱스를 사용할 수 없습니다. Hash 인덱스는 주로 메모리 기반의 데이터베이스에서 많이 사용합니다.



Fractal-Tree 알고리즘은 B-Tree의 단점을 보완하기 위해 고안된 알고리즘입니다. 값을 변형하지 않고 인덱싱하며 범용적인 목적으로 사용할 수 있다는 측면에서 B-Tree와 거의 비슷하지만 데이터가 저장되거나 삭제될 때 처리 비용을 상당히 줄일 수 있게 설계된 것이 특징입니다. 아직 B-Tree 알고리즘만큼 안정적이고 성숙되진 않았지만 아마도 조만간 B-Tree 인덱스의 상당 부분을 대체할 수 있지 않을까 생각합니다.


B-Tree 인덱스를 제대로 사용하려면 B-Tree의 기본적인 구조는 알고 있어야 합니다. B-Tree는 트리 구조의 최상위에 하나의 "루트 노드"가 존재하고 그 하위에 자식 노드가 붙어 있는 형태입니다. 트리 구조의 가장 하위에 있는 노드를 "리프 노드"라 하고, 트리 구조에서 루트 노드도 아니고 리프 노드도 아닌 중간 노드를 "브랜치 노드"라고 합니다. 데이터베이스에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리되는데, 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주소 값을 가지고 있습니다.


인덱스의 키값은 모두 정렬돼 있지만 데이터 파일의 레코드는 정렬돼 있지 않고 임의의 순서대로 저장돼 있습니다. 많은 사람이 데이터 파일의 레코드는 INSERT된 순서대로 저장되는 것으로 생각하지만 그렇지 않습니다. 만약 테이블의 레코드를 전혀 삭제나 변경없이 INSERT만 수행한다면 맞을 수도 있습니다. 하지만 레코드가 삭제되어 빈 공간이 생기면 그다음의 INSERT는 가능한 삭제된 공간을 재활용하도록 DBMS가 설계되기 때문에 항상 INSERT된 순서로 저장되는 것은 아닙니다.

대부분 RDBMS의 데이터 파일에서 레코드는 특정 기준으로 정렬되지 않고 임의의 순서대로 저장됩니다. 하지만 InnoDB 테이블에서 레코드는 클러스터되어 디스크에 저장되므로 기본적으로 프라이머리 키 순서대로 정렬되어 저장됩니다. 이는 오라클 IOT(Index organized table)나 MS-SQL의 클러스터 테이블과 같은 구조를 말합니다. 다른 DBMS에서는 클러스터링 기능이 선택 사항이지만, InnoDB에서는 사용자가 별도의 명령이나 옵션을 선택하지 않아도 디폴트로 클러스터링 테이
블이 생성됩니다. 클러스터링이란 비슷한 값들은 최대한 모아서 저장하는 방식을 의미합니다.
3) INDEX의 장점
- 키 값을 기초로 하여 테이블에서 검색과 정렬 속도를 향상시킵니다.
- 질의나 보고서에서 그룹화 작업의 속도를 향상시킵니다.
- 인덱스를 사용하면 테이블 행의 고유성을 강화시킬 수 있습니다.
- 테이블의 기본 키는 자동으로 인덱스 됩니다.
- 필드 중에는 데이터 형식 때문에 인덱스 될 수 없는 필드도 있습니다.
- 여러 필드로 이루어진(다중 필드) 인덱스를 사용하면 첫 필드 값이 같은 레코드도 구분할   수 있습니다.
  참고로 액세스에서 다중 필드 인덱스는 최대 10개의 필드를 포함할 수 있습니다.
  
4) INDEX의 단점
- 인덱스를 만들면 .mdb 파일 크기가 늘어난다.
- 여러 사용자 응용 프로그램에서의 여러 사용자가 한 페이지를 동시에 수정할 수 있는 병행성이 줄어든다.
- 인덱스 된 필드에서 데이터를 업데이트하거나, 레코드를 추가 또는 삭제할 때 성능이 떨어집니다.
- 인덱스가 데이터베이스 공간을 차지해 추가적인 공간이 필요해진다. (DB의 10퍼센트 내외의 공간이 추가로 필요)
- 인덱스를 생성하는데 시간이 많이 소요될 수 있다.
- 데이터 변경 작업이 자주 일어날 경우에 인덱스를 재작성해야 할 필요가 있기에 성능에 영향을 끼칠 수 있다.

따라서 어느 필드를 인덱스 해야 하는지 미리 시험해 보고 결정하는 것이 좋습니다. 인덱스를 추가하면 쿼리 속도가 1초 정도 빨라지지만, 데이터 행을 추가하는 속도는 2초 정도 느려지게 되어 여러 사용자가 사용하는 경우 레코드 잠금 문제가 발생할 수 있습니다.

또, 다른 필드에 대한 인덱스를 만들게 되면 성능이 별로 향상되지 않을 수도 있습니다. 예를 들어, 테이블에 회사 이름 필드와 성 필드가 이미 인덱스 된 경우에 우편 번호 필드를 추가로 인덱스에 포함해도 성능이 거의 향상되지 않습니다. 만드는 쿼리의 종류와 관계 없이 가장 고유한 값을 갖는 필드만 인덱스 해야 합니다.



5) INDEX의 목적
  
RDBMS에는 INDEX가 있습니다. 인덱스의 목적은 해당 RDBMS의 검색 속도를 높이는데 있습니다.
SELECT 쿼리의 WHERE절이나 JOIN 예약어를 사용했을때만 인덱스를 사용되며 SELECT 쿼리의 검색 속도를 빠르게 하는데 목적을 두고 있습니다.
※ DELETE,INSERT,UPDATE쿼리에는 해당 사항없으며 INDEX사용시 좀 느려집니다.


6) 인덱스를 생성해야 하는 경우와 그렇지 않은 경우
- 인덱스는 열 단위로 생성된다.
- WHERE절에서 사용되는 컬럼을 인덱스로 만든다.
- 데이터의 중복도가 높은 열은 인덱스로 만들어도 효용이 없다. (예 : 성별, 타입이 별로 없는 경우, 적은경우)
- 외래키가 사용되는 열에는 인덱스를 되도록 생성해주는 것이 좋다.
- JOIN에 자주 사용되는 열에는 인덱스를 생성해주는 것이 좋다.
- INSERT / UPDATE / DELETE가 얼마나 자주 일어나는지를 고려한다.
- 사용하지 않는 인덱스는 제거하자
  


. DML에 취약함 
ⓐ INSERT
: index split 현상이 발생할 수 있음.
index split - 인덱스의 Block들이 하나에서 두 개로 나누어지는 현상 
-> 인덱스는 데이터가 순서대로 정렬 되어야 함. 기존 블록에 여유 공간이 없는 상황에서  그 블록에 새로운 데이터가 입력되어야 할 경우
오라클이 기존 블록의 내용 중 일부를 새 블록에다가 기록한 후 기존 블록에 빈 공간을 만들어서 새로운 데이터를 추가하게 됨.
*성능면에서 매우 불리 
① index split은 새로운 블록을 할당 받고 key를 옮기는 복잡한 작업을 수행. 모든 수행 과정이 Redo에 기록.. 많은 양의 Redo를 유발함
② index split이 이루어지는 동안 해당 블록에 대해 키 값이 변경되면 안되므로 DML이 블로킹됨.
enq:TX-index contention 대기 이벤트 발생(RAC- gc current split)

ⓑ DELETE
테이블에서 데이터가 delete 될 경우 - 지워지고 다른 데이터가 그 공간을 사용 가능
index에서 데이터가 delete 될 경우 - 데이터가 지워지지 않고, 사용 안 됨 표시만 해 둔다.
->즉, 테이블에 데이터가 1만건 있는 경우, 인덱스에는 2만건이 있을 수 있다는 뜻
=> 인덱스를 사용해도 수행속도를 기대하기 힘들다.

ⓒ UPDATE : 인덱스에는 update 개념이 없음!!!
테이블에 update가 발생할 경우 인덱스에서는 delete가 먼저 발생한 후 새로운 작업의 insert 작업이 발생한다. delete와 insert 두 개의 작업이 인덱스에 동시에 일어나 다른 DML보다 더 큰 부하를 주게 됨.




ⓑ Non UNIQUE INDEX : 중복되는 데이터가 들어가야 하는 경우
 - 생성 문법
 SQL > CREATE INDEX 인덱스명
     2  ON 테이블이름(컬럼명 1 ASC|DESC, 컬럼명,....) ;

예 - professor table의 position 컬럼에 Non UNIQUE INDEX를 생성
SQL > create index idx_prof_position
    2   on professor(position);

ⓒ Function Based INDEX ( FBI - 함수기반 인덱스 )

* 인덱스는 where절에 오는 조건 컬럼이나 조인에 쓰이는 컬럼으로 만들어야 함
** 인덱스를 사용하려면 where 절의 조건을 절대로 다른 형태로 가공해서 사용하면 안된다.

꼭 써야 할 때
SAL + 100 = 200 이라는 형태로 써야할 때
-> 인덱스도 SAL+100 형태의 인덱스를 생성= 함수기반 인덱스 

SQL> create index idx_prof_pay_fbi
  2  on professor(pay+100);

Index created.

professor table에 pay+100이라는 컬럼이 없지만 인덱스를 만들 때 저 연산을 수행해서 인덱스를 만들어줌.

-> 임시적인 해결책은 될 수 있어도 근본적 처방은 아님
-> pay + 100을 생성했는데 쿼리의 조건이 변경되면 인덱스를 다시 생성해야 함
-> FBI는 기존 인덱스를 활용할 수 없다.(단점)

ⓓ DESCENDING INDEX : 내림차순으로 인덱스를 생성함
큰 값을 많이 조회하는 SQL에 생성하는 것이 좋음!
ex ) 계좌내역 최근 날짜부터 조회, 회사 매출

SQL> create index idx_prof_pay
  2  on professor(pay desc);

Index created.


하나의 메뉴에 오름차순과 내림차순을 한번에 조회 할 경우
: 오름차순, 내림차순 두 개의 인덱스를 만들면 DML의 성능에 악영향을 미침
-> 힌트를 사용 ( 아래나 위에서부터 읽도록 할 수 있음) 

ⓔ 결합 인덱스 (Composite INDEX) : 인덱스 생성시 두 개 이상의 컬럼을 합쳐서 인덱스 생성
주로 where 절의 조건 컬럼이 2개 이상이 and로 연결되어 사용되는 경우 많이 사용
-> 잘못 생성하게 되면 성능에 나쁜 영향을 미침!!

예) 사원 테이블에 총 50명이 있고, 남자 25명, 여자 25명
여자 중 이름이 '유관순'인 사람이 2명

사원 테이블에서 성별이 '여자' 이고 이름이 '유관순'인 사람을 찾을 때 :
SQL > SELECT 이름, 성별
FROM 사원
WHERE 성별 = '여자'
AND 이름 = '유관순';

* 결합 인덱스 생성 구문 예 :

SQL > CREATE INDEX idx_사원_성별_이름
   2  ON 사원(성별,이름);

**** 결합 인덱스 생성시 컬럼의 배치 순서 

case 1 : ON 사원(성별, 이름) 

50 명 -> 여자 -> 25명 -> 유관순 -> 2명
        50                      => 25회 검사

case 2 : ON 사원(이름, 성별)

50명 -> 유관순 -> 2명 -> 여자 -> 2명
        50                      => 2회 검사


=> 같은 테이블에 같은 SQL이지만 결합 인덱스를 어떻게 생성하는가에 따라 속도나 검사 횟수가 완전히 달라지게 된다. (신중히 생성...)


인덱스는 범위 스캔(Range Scan)을 한다

인덱스는 키 컬럼순으로 정렬되어 있기때문에 특정값을 찾다가 해당 범위를 넘어서는 값을 만나면 멈춘다. (=Range Scan)

인덱스에 가장 많이 사용되는 구조 = B-tree

인덱스를 저장하는 블럭들이 트리구조를 이루고 있다.

root block과 branch block, leaf block이 있고 B-tree는 기본적으로 leaf block의 깊이가 모두 동일하게 균형(Balanced)이 잡혀있다.




------------------------------------------------------------------------------------------------------


UNIQUE 제약조건을 만들면 자동으로 UNIQUE인덱스를 생성해준다 이때 생성되는 INDEX는 UNIQUE나 기본키 겍체와 동일하게 생성된다.인덱스를 생성할때 주의 할 점은 일반적으로 로우수 15퍼센트 이하 데이터를 조회할때 생성한다.
테이블 건수가 적다면 굳이 만들 필요가 없다. 데이터 유일성의 정도가 좋거나 범위가 넓은 값으 가진 칼럼을 인덱스로 만드는 것이 좋다. NULL이 많은 칼럼은 인덱스 칼럼으로 만들기 적절치 않다 데이터의 유일성 정도가 좋거나 범위가 넓은 값을 인덱스로 만드는 것이 좋다. 결합인덱스를 만들때는 칼럼의 순서가 중요하다. 테이블에 만들 수있는 인덱스의 수는 제한이 없으나 너무 많이 만들면 성능 부하가 발생한다. 또한 스켄성능을 극대화 하기 위해 만든 겍체이지만 너무 많이 생성한다면 INSERT, DELETE, UPDATE시에 부하가 발생해 배보다 배꼽이 큰 결과가 발생한다.



DROP INDEX 스키마.인덱스명;



시노님은 동의어라는 뜻이고 데이터 베이스는 각자 고유한 이름이 있는데 이 겍체들에게 동의어(별명)를 만드는 것이 시노님이고 데이터베이스 겍체에 속한다. 
시노님 생성 
CREATE OR REPLACE PUBLIC SYNONYM 스키마명.시노님명
FOR 스키마명.겍체명; 
PUBLIC은 SYS권한이 있는 사용자만 생성 삭제가 가능하고 PRIVATE는 생성가능하다. FOR이하 겍체에서는 테이블,뷰,함수,페키지,시퀀스 등이 올 수있다.

--------------------------------------------------------------------------------------------------
시노님을 사용하는 이유
① 데이터베이스의 투명성을 제공하기 위해서 사용 한다고 보면 된다. 시노님은 다른 유저의 객체를 참조할 때 많이 사용을 한다.

② 만약에 실무에서 다른 유저의 객체를 참조할 경우가 있을 때 시노님을 생성해서 사용을 하면은 추후에 참조하고 있는 오프젝트가 이름을 바꾸거나 이동할 경우 객체를 사용하는 SQL문을 모두 다시 고치는 것이 아니라 시노님만 다시 정의하면 되기 때문에 매우 편리 하다.

③ 객체의 긴 이름을 사용하기 편한 짧은 이름으로 해서 SQL코딩을 단순화 시킬 수 있다.

④ 또한 객체를 참조하는 사용자의 오브젝트를 감추 수 있기 때문에 이에 대한 보안을 유지할 수 있다. 시노님을 사용하는 유저는 참조하고 있는 객체를에 대한 소유자, 이름, 서버이름을 모르고 시노님 이름만 알아도 사용 할 수 있다.

시노님을 사용하는 경우
객체의 실제 이름과 소유자 그리고 위치를 감춤으로써 데이터베이스 보안을 개선하는데 사용 한다

객체의 Public Access를 제공 한다

Remote 데이터베이스의 TABLE, VIEW, PROGRAM UNIT를 위해 투명성을 제공 한다.

데이터베이스 사용자를 위해 SQL 문을 단순화 할 수 있다.

시노님의 두 가지 종류
Private Synonym : 전용 시노님은 특정 사용자만 이용할수 있다.

Public Synonym : 공용 시노님은 공용 사용자 그룹이 소유하며 그 데이터베이스에 있는 모든 사용자가 공유 한다.


시노님 예제
scott USER의 emp테이블을 test USER가 사용 하는 예제.

 
-- ① 먼저 scott/tiger USER로 접속해서 test USER에게 
--   emp 테이블을 조작할 권한을 부여합니다.
SQL> GRANT ALL ON  emp TO test; 

-- ② test USER로 접속해 동의어를 생성합니다. 
SQL> CONNECT test/test 
SQL> CREATE SYNONYM scott_emp FOR scott.emp ; 

-- scott USER가 소유하고 있는 emp 테이블에 대해 
   scott_emp라는 일반 시노님을 생성했다. 
-- scott 사용자의 emp테이블을 test 사용자가 
   scott_emp라는 동의어로 사용 합니다. 

-- ③ 시노님을 이용한 쿼리
SQL> SELECT empno, ename FROM  scott_emp; 

-- 일반 테이블을 쿼리
SQL> SELECT empno,  ename FROM  scott.emp; 
 이 두 쿼리의 결과는 같다. 

   EMPNO ENAME
-------- ---------
    7369 SMITH
    7499 ALLEN
...

-- ④ 동의어 삭제 
SQL> DROP SYNONYM scott_emp; 

-- 시노님을 이용한 조회
SQL> SELECT empno,  ename FROM  scott_emp; 
         라인 1 에 오류:
     ORA-00942: 테이블 또는 뷰가 존재하지 않습니다  
	


----------------------------------------------------------------------------------------------------





시퀀스는 자동순번을 반환하는 데이터베이스 겍체이다. 예를들어 사원번호가 100부터 206까지 인데 숫자형으로 되었다
하지만 신입사원이 들어 온다면 207이라는 숫자를 얻으려면 기존 사원번호중 최댓값을 구해 1을 더해야 하지만 특정 로직을 통해 사번을 추출하는 것이 아니라 증감연산을 통해 숫자를 구할때 시퀀스를 사용하면 편리하다.

----------------------------------------------------------------------------------------------------
시퀀스란?
- 유일(UNIQUE)한 값을 생성해주는 오라클 객체이다.
- 시퀀스를 생성하면 기본키와 같이 순차적으로 증가하는 컬럼을 자동적으로 생성 할 수 있다.
- 보통 PRIMARY KEY 값을 생성하기 위해 사용 한다.
- 메모리에 Cache되었을 때 시퀀스값의 액세스 효율이 증가 한다.
- 시퀀스는 테이블과는 독립적으로 저장되고 생성된다.
-- 시퀀스 생성 Syntax
CREATE SEQUENCE sequence_name
    [START WITH n]
    [INCREMENT BY n]
    [MAXVALUE n | NOMAXVALUE]
    [MINVALUE n | NOMINVALUE]
    [CYCLE | NOCYCLE]
    [CACHE | NOCACHE]


시퀀스 수정

TART WITH 값을 제외하고 ALTER SEQUENCE 명령어로 수정 할 수 있다.


-- 시퀀스 수정 Syntax
ALTER SEQUENCE sequence_name
    [INCREMENT BY n]
    [MAXVALUE n | NOMAXVALUE]
    [MINVALUE n | NOMINVALUE]
    [CYCLE | NOCYCLE]
    [CACHE | NOCACHE]






----------------------------------------------------------------------------------------------------

시퀀스 생성
CREATE SEQUENCE 스키마명.시퀀스명;
INCREMENT BY 증감숫자--시작 숫자의 디폴트 값이 증가일떼 MINVALUE 감소일경우 MAXVALUE
START WITH 시작숫자
NOMNIVALUE | MINVALUE 최솟값--디폴트 값으로 증가일때 1028-1 감소의 경우  최솟값은 시작숫자와 작거나 같아야하고 MAXVALUE 보다 작아야한다.
NOMAXVALUE | MAXVALUE --최댓값 최댓값은 시작숫자와 같거나 커야하고 MINVALUE보다 커야한다. 
NOCYCLE | CYCLE --NOCYCLE 디폴트 값으로 최대나 최솟값에 도달하면 생성중지 CYCLE 증가는 최댓값에 도달하면 다시 시작 감소는 최솟값에 도달하면 다시 최댓값에서 시작
NOCACHE | CACHE; --NOCACHE 디폴트 메모리에 시퀀스값을 미리 할당해 놓지 않으면 디폴트 값은 20 CACHE 메모리에 시퀀스 값에 미리 할당 해놓음


시퀀스 삭제 DROP SEQUENCE 스키마명.시퀀스명;














































